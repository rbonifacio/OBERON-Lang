//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <iostream>
#include <vector>
#include "Absyn.H"

/********************   Module    ********************/
Module::Module(Ident p1, ListVarDec *p2, ListProcDec *p3, ListStmt *p4, Ident p5)
{
  ident_1 = p1;
  listvardec_ = p2;
  listprocdec_ = p3;
  liststmt_ = p4;
  ident_2 = p5;

}

Module::Module(const Module & other)
{
  ident_1 = other.ident_1;
  listvardec_ = other.listvardec_->clone();
  listprocdec_ = other.listprocdec_->clone();
  liststmt_ = other.liststmt_->clone();
  ident_2 = other.ident_2;

}

Module &Module::operator=(const Module & other)
{
  Module tmp(other);
  swap(tmp);
  return *this;
}

void Module::swap(Module & other)
{
  std::swap(ident_1, other.ident_1);
  std::swap(listvardec_, other.listvardec_);
  std::swap(listprocdec_, other.listprocdec_);
  std::swap(liststmt_, other.liststmt_);
  std::swap(ident_2, other.ident_2);

}

Module::~Module()
{
  delete(listvardec_);
  delete(listprocdec_);
  delete(liststmt_);

}

void Module::accept(Visitor *v)
{
  v->visitModule(this);
}

Module *Module::clone() const
{
  return new Module(*this);
}



/********************   TInt    ********************/
TInt::TInt()
{

}

TInt::TInt(const TInt & other)
{

}

TInt &TInt::operator=(const TInt & other)
{
  TInt tmp(other);
  swap(tmp);
  return *this;
}

void TInt::swap(TInt & other)
{

}

TInt::~TInt()
{

}

void TInt::accept(Visitor *v)
{
  v->visitTInt(this);
}

TInt *TInt::clone() const
{
  return new TInt(*this);
}



/********************   TBool    ********************/
TBool::TBool()
{

}

TBool::TBool(const TBool & other)
{

}

TBool &TBool::operator=(const TBool & other)
{
  TBool tmp(other);
  swap(tmp);
  return *this;
}

void TBool::swap(TBool & other)
{

}

TBool::~TBool()
{

}

void TBool::accept(Visitor *v)
{
  v->visitTBool(this);
}

TBool *TBool::clone() const
{
  return new TBool(*this);
}



/********************   Decl    ********************/
Decl::Decl(ListIdent *p1, Type *p2)
{
  listident_ = p1;
  type_ = p2;

}

Decl::Decl(const Decl & other)
{
  listident_ = other.listident_->clone();
  type_ = other.type_->clone();

}

Decl &Decl::operator=(const Decl & other)
{
  Decl tmp(other);
  swap(tmp);
  return *this;
}

void Decl::swap(Decl & other)
{
  std::swap(listident_, other.listident_);
  std::swap(type_, other.type_);

}

Decl::~Decl()
{
  delete(listident_);
  delete(type_);

}

void Decl::accept(Visitor *v)
{
  v->visitDecl(this);
}

Decl *Decl::clone() const
{
  return new Decl(*this);
}



/********************   FPDecl    ********************/
FPDecl::FPDecl(ListIdent *p1, Type *p2)
{
  listident_ = p1;
  type_ = p2;

}

FPDecl::FPDecl(const FPDecl & other)
{
  listident_ = other.listident_->clone();
  type_ = other.type_->clone();

}

FPDecl &FPDecl::operator=(const FPDecl & other)
{
  FPDecl tmp(other);
  swap(tmp);
  return *this;
}

void FPDecl::swap(FPDecl & other)
{
  std::swap(listident_, other.listident_);
  std::swap(type_, other.type_);

}

FPDecl::~FPDecl()
{
  delete(listident_);
  delete(type_);

}

void FPDecl::accept(Visitor *v)
{
  v->visitFPDecl(this);
}

FPDecl *FPDecl::clone() const
{
  return new FPDecl(*this);
}



/********************   PDec    ********************/
PDec::PDec(Ident p1, ListFPmtDec *p2, ListVarDec *p3, ListStmt *p4)
{
  ident_ = p1;
  listfpmtdec_ = p2;
  listvardec_ = p3;
  liststmt_ = p4;

}

PDec::PDec(const PDec & other)
{
  ident_ = other.ident_;
  listfpmtdec_ = other.listfpmtdec_->clone();
  listvardec_ = other.listvardec_->clone();
  liststmt_ = other.liststmt_->clone();

}

PDec &PDec::operator=(const PDec & other)
{
  PDec tmp(other);
  swap(tmp);
  return *this;
}

void PDec::swap(PDec & other)
{
  std::swap(ident_, other.ident_);
  std::swap(listfpmtdec_, other.listfpmtdec_);
  std::swap(listvardec_, other.listvardec_);
  std::swap(liststmt_, other.liststmt_);

}

PDec::~PDec()
{
  delete(listfpmtdec_);
  delete(listvardec_);
  delete(liststmt_);

}

void PDec::accept(Visitor *v)
{
  v->visitPDec(this);
}

PDec *PDec::clone() const
{
  return new PDec(*this);
}



/********************   ELt    ********************/
ELt::ELt(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ELt::ELt(const ELt & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ELt &ELt::operator=(const ELt & other)
{
  ELt tmp(other);
  swap(tmp);
  return *this;
}

void ELt::swap(ELt & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ELt::~ELt()
{
  delete(exp_1);
  delete(exp_2);

}

void ELt::accept(Visitor *v)
{
  v->visitELt(this);
}

ELt *ELt::clone() const
{
  return new ELt(*this);
}



/********************   EGt    ********************/
EGt::EGt(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EGt::EGt(const EGt & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EGt &EGt::operator=(const EGt & other)
{
  EGt tmp(other);
  swap(tmp);
  return *this;
}

void EGt::swap(EGt & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EGt::~EGt()
{
  delete(exp_1);
  delete(exp_2);

}

void EGt::accept(Visitor *v)
{
  v->visitEGt(this);
}

EGt *EGt::clone() const
{
  return new EGt(*this);
}



/********************   EEq    ********************/
EEq::EEq(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EEq::EEq(const EEq & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EEq &EEq::operator=(const EEq & other)
{
  EEq tmp(other);
  swap(tmp);
  return *this;
}

void EEq::swap(EEq & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EEq::~EEq()
{
  delete(exp_1);
  delete(exp_2);

}

void EEq::accept(Visitor *v)
{
  v->visitEEq(this);
}

EEq *EEq::clone() const
{
  return new EEq(*this);
}



/********************   ENEq    ********************/
ENEq::ENEq(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ENEq::ENEq(const ENEq & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ENEq &ENEq::operator=(const ENEq & other)
{
  ENEq tmp(other);
  swap(tmp);
  return *this;
}

void ENEq::swap(ENEq & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ENEq::~ENEq()
{
  delete(exp_1);
  delete(exp_2);

}

void ENEq::accept(Visitor *v)
{
  v->visitENEq(this);
}

ENEq *ENEq::clone() const
{
  return new ENEq(*this);
}



/********************   EAdd    ********************/
EAdd::EAdd(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EAdd::EAdd(const EAdd & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EAdd &EAdd::operator=(const EAdd & other)
{
  EAdd tmp(other);
  swap(tmp);
  return *this;
}

void EAdd::swap(EAdd & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EAdd::~EAdd()
{
  delete(exp_1);
  delete(exp_2);

}

void EAdd::accept(Visitor *v)
{
  v->visitEAdd(this);
}

EAdd *EAdd::clone() const
{
  return new EAdd(*this);
}



/********************   ESub    ********************/
ESub::ESub(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ESub::ESub(const ESub & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ESub &ESub::operator=(const ESub & other)
{
  ESub tmp(other);
  swap(tmp);
  return *this;
}

void ESub::swap(ESub & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ESub::~ESub()
{
  delete(exp_1);
  delete(exp_2);

}

void ESub::accept(Visitor *v)
{
  v->visitESub(this);
}

ESub *ESub::clone() const
{
  return new ESub(*this);
}



/********************   EMul    ********************/
EMul::EMul(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EMul::EMul(const EMul & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EMul &EMul::operator=(const EMul & other)
{
  EMul tmp(other);
  swap(tmp);
  return *this;
}

void EMul::swap(EMul & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EMul::~EMul()
{
  delete(exp_1);
  delete(exp_2);

}

void EMul::accept(Visitor *v)
{
  v->visitEMul(this);
}

EMul *EMul::clone() const
{
  return new EMul(*this);
}



/********************   EDiv    ********************/
EDiv::EDiv(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EDiv::EDiv(const EDiv & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EDiv &EDiv::operator=(const EDiv & other)
{
  EDiv tmp(other);
  swap(tmp);
  return *this;
}

void EDiv::swap(EDiv & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EDiv::~EDiv()
{
  delete(exp_1);
  delete(exp_2);

}

void EDiv::accept(Visitor *v)
{
  v->visitEDiv(this);
}

EDiv *EDiv::clone() const
{
  return new EDiv(*this);
}



/********************   EOr    ********************/
EOr::EOr(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EOr::EOr(const EOr & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EOr &EOr::operator=(const EOr & other)
{
  EOr tmp(other);
  swap(tmp);
  return *this;
}

void EOr::swap(EOr & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EOr::~EOr()
{
  delete(exp_1);
  delete(exp_2);

}

void EOr::accept(Visitor *v)
{
  v->visitEOr(this);
}

EOr *EOr::clone() const
{
  return new EOr(*this);
}



/********************   EAnd    ********************/
EAnd::EAnd(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EAnd::EAnd(const EAnd & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EAnd &EAnd::operator=(const EAnd & other)
{
  EAnd tmp(other);
  swap(tmp);
  return *this;
}

void EAnd::swap(EAnd & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EAnd::~EAnd()
{
  delete(exp_1);
  delete(exp_2);

}

void EAnd::accept(Visitor *v)
{
  v->visitEAnd(this);
}

EAnd *EAnd::clone() const
{
  return new EAnd(*this);
}



/********************   Call    ********************/
Call::Call(Ident p1, ListExp *p2)
{
  ident_ = p1;
  listexp_ = p2;

}

Call::Call(const Call & other)
{
  ident_ = other.ident_;
  listexp_ = other.listexp_->clone();

}

Call &Call::operator=(const Call & other)
{
  Call tmp(other);
  swap(tmp);
  return *this;
}

void Call::swap(Call & other)
{
  std::swap(ident_, other.ident_);
  std::swap(listexp_, other.listexp_);

}

Call::~Call()
{
  delete(listexp_);

}

void Call::accept(Visitor *v)
{
  v->visitCall(this);
}

Call *Call::clone() const
{
  return new Call(*this);
}



/********************   EVar    ********************/
EVar::EVar(Ident p1)
{
  ident_ = p1;

}

EVar::EVar(const EVar & other)
{
  ident_ = other.ident_;

}

EVar &EVar::operator=(const EVar & other)
{
  EVar tmp(other);
  swap(tmp);
  return *this;
}

void EVar::swap(EVar & other)
{
  std::swap(ident_, other.ident_);

}

EVar::~EVar()
{

}

void EVar::accept(Visitor *v)
{
  v->visitEVar(this);
}

EVar *EVar::clone() const
{
  return new EVar(*this);
}



/********************   EStr    ********************/
EStr::EStr(String p1)
{
  string_ = p1;

}

EStr::EStr(const EStr & other)
{
  string_ = other.string_;

}

EStr &EStr::operator=(const EStr & other)
{
  EStr tmp(other);
  swap(tmp);
  return *this;
}

void EStr::swap(EStr & other)
{
  std::swap(string_, other.string_);

}

EStr::~EStr()
{

}

void EStr::accept(Visitor *v)
{
  v->visitEStr(this);
}

EStr *EStr::clone() const
{
  return new EStr(*this);
}



/********************   EInt    ********************/
EInt::EInt(Integer p1)
{
  integer_ = p1;

}

EInt::EInt(const EInt & other)
{
  integer_ = other.integer_;

}

EInt &EInt::operator=(const EInt & other)
{
  EInt tmp(other);
  swap(tmp);
  return *this;
}

void EInt::swap(EInt & other)
{
  std::swap(integer_, other.integer_);

}

EInt::~EInt()
{

}

void EInt::accept(Visitor *v)
{
  v->visitEInt(this);
}

EInt *EInt::clone() const
{
  return new EInt(*this);
}



/********************   EFalse    ********************/
EFalse::EFalse()
{

}

EFalse::EFalse(const EFalse & other)
{

}

EFalse &EFalse::operator=(const EFalse & other)
{
  EFalse tmp(other);
  swap(tmp);
  return *this;
}

void EFalse::swap(EFalse & other)
{

}

EFalse::~EFalse()
{

}

void EFalse::accept(Visitor *v)
{
  v->visitEFalse(this);
}

EFalse *EFalse::clone() const
{
  return new EFalse(*this);
}



/********************   ETrue    ********************/
ETrue::ETrue()
{

}

ETrue::ETrue(const ETrue & other)
{

}

ETrue &ETrue::operator=(const ETrue & other)
{
  ETrue tmp(other);
  swap(tmp);
  return *this;
}

void ETrue::swap(ETrue & other)
{

}

ETrue::~ETrue()
{

}

void ETrue::accept(Visitor *v)
{
  v->visitETrue(this);
}

ETrue *ETrue::clone() const
{
  return new ETrue(*this);
}



/********************   EDouble    ********************/
EDouble::EDouble(Double p1)
{
  double_ = p1;

}

EDouble::EDouble(const EDouble & other)
{
  double_ = other.double_;

}

EDouble &EDouble::operator=(const EDouble & other)
{
  EDouble tmp(other);
  swap(tmp);
  return *this;
}

void EDouble::swap(EDouble & other)
{
  std::swap(double_, other.double_);

}

EDouble::~EDouble()
{

}

void EDouble::accept(Visitor *v)
{
  v->visitEDouble(this);
}

EDouble *EDouble::clone() const
{
  return new EDouble(*this);
}



/********************   SCall    ********************/
SCall::SCall(Ident p1, ListExp *p2)
{
  ident_ = p1;
  listexp_ = p2;

}

SCall::SCall(const SCall & other)
{
  ident_ = other.ident_;
  listexp_ = other.listexp_->clone();

}

SCall &SCall::operator=(const SCall & other)
{
  SCall tmp(other);
  swap(tmp);
  return *this;
}

void SCall::swap(SCall & other)
{
  std::swap(ident_, other.ident_);
  std::swap(listexp_, other.listexp_);

}

SCall::~SCall()
{
  delete(listexp_);

}

void SCall::accept(Visitor *v)
{
  v->visitSCall(this);
}

SCall *SCall::clone() const
{
  return new SCall(*this);
}



/********************   SAssignment    ********************/
SAssignment::SAssignment(Ident p1, Exp *p2)
{
  ident_ = p1;
  exp_ = p2;

}

SAssignment::SAssignment(const SAssignment & other)
{
  ident_ = other.ident_;
  exp_ = other.exp_->clone();

}

SAssignment &SAssignment::operator=(const SAssignment & other)
{
  SAssignment tmp(other);
  swap(tmp);
  return *this;
}

void SAssignment::swap(SAssignment & other)
{
  std::swap(ident_, other.ident_);
  std::swap(exp_, other.exp_);

}

SAssignment::~SAssignment()
{
  delete(exp_);

}

void SAssignment::accept(Visitor *v)
{
  v->visitSAssignment(this);
}

SAssignment *SAssignment::clone() const
{
  return new SAssignment(*this);
}



/********************   SWhile    ********************/
SWhile::SWhile(Exp *p1, Stmt *p2)
{
  exp_ = p1;
  stmt_ = p2;

}

SWhile::SWhile(const SWhile & other)
{
  exp_ = other.exp_->clone();
  stmt_ = other.stmt_->clone();

}

SWhile &SWhile::operator=(const SWhile & other)
{
  SWhile tmp(other);
  swap(tmp);
  return *this;
}

void SWhile::swap(SWhile & other)
{
  std::swap(exp_, other.exp_);
  std::swap(stmt_, other.stmt_);

}

SWhile::~SWhile()
{
  delete(exp_);
  delete(stmt_);

}

void SWhile::accept(Visitor *v)
{
  v->visitSWhile(this);
}

SWhile *SWhile::clone() const
{
  return new SWhile(*this);
}



/********************   SIfThenElse    ********************/
SIfThenElse::SIfThenElse(Exp *p1, Stmt *p2, Stmt *p3)
{
  exp_ = p1;
  stmt_1 = p2;
  stmt_2 = p3;

}

SIfThenElse::SIfThenElse(const SIfThenElse & other)
{
  exp_ = other.exp_->clone();
  stmt_1 = other.stmt_1->clone();
  stmt_2 = other.stmt_2->clone();

}

SIfThenElse &SIfThenElse::operator=(const SIfThenElse & other)
{
  SIfThenElse tmp(other);
  swap(tmp);
  return *this;
}

void SIfThenElse::swap(SIfThenElse & other)
{
  std::swap(exp_, other.exp_);
  std::swap(stmt_1, other.stmt_1);
  std::swap(stmt_2, other.stmt_2);

}

SIfThenElse::~SIfThenElse()
{
  delete(exp_);
  delete(stmt_1);
  delete(stmt_2);

}

void SIfThenElse::accept(Visitor *v)
{
  v->visitSIfThenElse(this);
}

SIfThenElse *SIfThenElse::clone() const
{
  return new SIfThenElse(*this);
}



/********************   SIfThen    ********************/
SIfThen::SIfThen(Exp *p1, Stmt *p2)
{
  exp_ = p1;
  stmt_ = p2;

}

SIfThen::SIfThen(const SIfThen & other)
{
  exp_ = other.exp_->clone();
  stmt_ = other.stmt_->clone();

}

SIfThen &SIfThen::operator=(const SIfThen & other)
{
  SIfThen tmp(other);
  swap(tmp);
  return *this;
}

void SIfThen::swap(SIfThen & other)
{
  std::swap(exp_, other.exp_);
  std::swap(stmt_, other.stmt_);

}

SIfThen::~SIfThen()
{
  delete(exp_);
  delete(stmt_);

}

void SIfThen::accept(Visitor *v)
{
  v->visitSIfThen(this);
}

SIfThen *SIfThen::clone() const
{
  return new SIfThen(*this);
}




/********************   ListExp    ********************/

void ListExp::accept(Visitor *v)
{
  v->visitListExp(this);
}


ListExp *ListExp::clone() const
{
  return new ListExp(*this);
}


/********************   ListStmt    ********************/

void ListStmt::accept(Visitor *v)
{
  v->visitListStmt(this);
}


ListStmt *ListStmt::clone() const
{
  return new ListStmt(*this);
}


/********************   ListIdent    ********************/

void ListIdent::accept(Visitor *v)
{
  v->visitListIdent(this);
}


ListIdent *ListIdent::clone() const
{
  return new ListIdent(*this);
}


/********************   ListVarDec    ********************/

void ListVarDec::accept(Visitor *v)
{
  v->visitListVarDec(this);
}


ListVarDec *ListVarDec::clone() const
{
  return new ListVarDec(*this);
}


/********************   ListFPmtDec    ********************/

void ListFPmtDec::accept(Visitor *v)
{
  v->visitListFPmtDec(this);
}


ListFPmtDec *ListFPmtDec::clone() const
{
  return new ListFPmtDec(*this);
}


/********************   ListProcDec    ********************/

void ListProcDec::accept(Visitor *v)
{
  v->visitListProcDec(this);
}


ListProcDec *ListProcDec::clone() const
{
  return new ListProcDec(*this);
}




