#ifndef ABSYN_HEADER
#define ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface generated by the BNF Converter.

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;




/********************   Forward Declarations    ********************/

class ModuleDec;
class Type;
class VarDec;
class FPmtDec;
class ProcDec;
class Exp;
class Stmt;
class Module;
class TInt;
class TBool;
class Decl;
class FPDecl;
class PDec;
class ELt;
class EGt;
class EEq;
class ENEq;
class EAdd;
class ESub;
class EMul;
class EDiv;
class EOr;
class EAnd;
class Call;
class EVar;
class EStr;
class EInt;
class EFalse;
class ETrue;
class EDouble;
class SCall;
class SAssignment;
class SWhile;
class SIfThenElse;
class SIfThen;
class ListExp;
class ListStmt;
class ListIdent;
class ListVarDec;
class ListFPmtDec;
class ListProcDec;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitModuleDec(ModuleDec *p) = 0;
  virtual void visitType(Type *p) = 0;
  virtual void visitVarDec(VarDec *p) = 0;
  virtual void visitFPmtDec(FPmtDec *p) = 0;
  virtual void visitProcDec(ProcDec *p) = 0;
  virtual void visitExp(Exp *p) = 0;
  virtual void visitStmt(Stmt *p) = 0;
  virtual void visitModule(Module *p) = 0;
  virtual void visitTInt(TInt *p) = 0;
  virtual void visitTBool(TBool *p) = 0;
  virtual void visitDecl(Decl *p) = 0;
  virtual void visitFPDecl(FPDecl *p) = 0;
  virtual void visitPDec(PDec *p) = 0;
  virtual void visitELt(ELt *p) = 0;
  virtual void visitEGt(EGt *p) = 0;
  virtual void visitEEq(EEq *p) = 0;
  virtual void visitENEq(ENEq *p) = 0;
  virtual void visitEAdd(EAdd *p) = 0;
  virtual void visitESub(ESub *p) = 0;
  virtual void visitEMul(EMul *p) = 0;
  virtual void visitEDiv(EDiv *p) = 0;
  virtual void visitEOr(EOr *p) = 0;
  virtual void visitEAnd(EAnd *p) = 0;
  virtual void visitCall(Call *p) = 0;
  virtual void visitEVar(EVar *p) = 0;
  virtual void visitEStr(EStr *p) = 0;
  virtual void visitEInt(EInt *p) = 0;
  virtual void visitEFalse(EFalse *p) = 0;
  virtual void visitETrue(ETrue *p) = 0;
  virtual void visitEDouble(EDouble *p) = 0;
  virtual void visitSCall(SCall *p) = 0;
  virtual void visitSAssignment(SAssignment *p) = 0;
  virtual void visitSWhile(SWhile *p) = 0;
  virtual void visitSIfThenElse(SIfThenElse *p) = 0;
  virtual void visitSIfThen(SIfThen *p) = 0;
  virtual void visitListExp(ListExp *p) = 0;
  virtual void visitListStmt(ListStmt *p) = 0;
  virtual void visitListIdent(ListIdent *p) = 0;
  virtual void visitListVarDec(ListVarDec *p) = 0;
  virtual void visitListFPmtDec(ListFPmtDec *p) = 0;
  virtual void visitListProcDec(ListProcDec *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class ModuleDec : public Visitable
{
public:
  virtual ModuleDec *clone() const = 0;

};

class Type : public Visitable
{
public:
  virtual Type *clone() const = 0;

};

class VarDec : public Visitable
{
public:
  virtual VarDec *clone() const = 0;

};

class FPmtDec : public Visitable
{
public:
  virtual FPmtDec *clone() const = 0;

};

class ProcDec : public Visitable
{
public:
  virtual ProcDec *clone() const = 0;

};

class Exp : public Visitable
{
public:
  virtual Exp *clone() const = 0;

};

class Stmt : public Visitable
{
public:
  virtual Stmt *clone() const = 0;

};



class Module : public ModuleDec
{
public:
  Ident ident_1;
  ListVarDec *listvardec_;
  ListProcDec *listprocdec_;
  ListStmt *liststmt_;
  Ident ident_2;

  Module(const Module &);
  Module &operator=(const Module &);
  Module(Ident p1, ListVarDec *p2, ListProcDec *p3, ListStmt *p4, Ident p5);
  ~Module();
  virtual void accept(Visitor *v);
  virtual Module *clone() const;
  void swap(Module &);
};

class TInt : public Type
{
public:

  TInt(const TInt &);
  TInt &operator=(const TInt &);
  TInt();
  ~TInt();
  virtual void accept(Visitor *v);
  virtual TInt *clone() const;
  void swap(TInt &);
};

class TBool : public Type
{
public:

  TBool(const TBool &);
  TBool &operator=(const TBool &);
  TBool();
  ~TBool();
  virtual void accept(Visitor *v);
  virtual TBool *clone() const;
  void swap(TBool &);
};

class Decl : public VarDec
{
public:
  ListIdent *listident_;
  Type *type_;

  Decl(const Decl &);
  Decl &operator=(const Decl &);
  Decl(ListIdent *p1, Type *p2);
  ~Decl();
  virtual void accept(Visitor *v);
  virtual Decl *clone() const;
  void swap(Decl &);
};

class FPDecl : public FPmtDec
{
public:
  ListIdent *listident_;
  Type *type_;

  FPDecl(const FPDecl &);
  FPDecl &operator=(const FPDecl &);
  FPDecl(ListIdent *p1, Type *p2);
  ~FPDecl();
  virtual void accept(Visitor *v);
  virtual FPDecl *clone() const;
  void swap(FPDecl &);
};

class PDec : public ProcDec
{
public:
  Ident ident_;
  ListFPmtDec *listfpmtdec_;
  ListVarDec *listvardec_;
  ListStmt *liststmt_;

  PDec(const PDec &);
  PDec &operator=(const PDec &);
  PDec(Ident p1, ListFPmtDec *p2, ListVarDec *p3, ListStmt *p4);
  ~PDec();
  virtual void accept(Visitor *v);
  virtual PDec *clone() const;
  void swap(PDec &);
};

class ELt : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ELt(const ELt &);
  ELt &operator=(const ELt &);
  ELt(Exp *p1, Exp *p2);
  ~ELt();
  virtual void accept(Visitor *v);
  virtual ELt *clone() const;
  void swap(ELt &);
};

class EGt : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EGt(const EGt &);
  EGt &operator=(const EGt &);
  EGt(Exp *p1, Exp *p2);
  ~EGt();
  virtual void accept(Visitor *v);
  virtual EGt *clone() const;
  void swap(EGt &);
};

class EEq : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EEq(const EEq &);
  EEq &operator=(const EEq &);
  EEq(Exp *p1, Exp *p2);
  ~EEq();
  virtual void accept(Visitor *v);
  virtual EEq *clone() const;
  void swap(EEq &);
};

class ENEq : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ENEq(const ENEq &);
  ENEq &operator=(const ENEq &);
  ENEq(Exp *p1, Exp *p2);
  ~ENEq();
  virtual void accept(Visitor *v);
  virtual ENEq *clone() const;
  void swap(ENEq &);
};

class EAdd : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EAdd(const EAdd &);
  EAdd &operator=(const EAdd &);
  EAdd(Exp *p1, Exp *p2);
  ~EAdd();
  virtual void accept(Visitor *v);
  virtual EAdd *clone() const;
  void swap(EAdd &);
};

class ESub : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ESub(const ESub &);
  ESub &operator=(const ESub &);
  ESub(Exp *p1, Exp *p2);
  ~ESub();
  virtual void accept(Visitor *v);
  virtual ESub *clone() const;
  void swap(ESub &);
};

class EMul : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EMul(const EMul &);
  EMul &operator=(const EMul &);
  EMul(Exp *p1, Exp *p2);
  ~EMul();
  virtual void accept(Visitor *v);
  virtual EMul *clone() const;
  void swap(EMul &);
};

class EDiv : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EDiv(const EDiv &);
  EDiv &operator=(const EDiv &);
  EDiv(Exp *p1, Exp *p2);
  ~EDiv();
  virtual void accept(Visitor *v);
  virtual EDiv *clone() const;
  void swap(EDiv &);
};

class EOr : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EOr(const EOr &);
  EOr &operator=(const EOr &);
  EOr(Exp *p1, Exp *p2);
  ~EOr();
  virtual void accept(Visitor *v);
  virtual EOr *clone() const;
  void swap(EOr &);
};

class EAnd : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EAnd(const EAnd &);
  EAnd &operator=(const EAnd &);
  EAnd(Exp *p1, Exp *p2);
  ~EAnd();
  virtual void accept(Visitor *v);
  virtual EAnd *clone() const;
  void swap(EAnd &);
};

class Call : public Exp
{
public:
  Ident ident_;
  ListExp *listexp_;

  Call(const Call &);
  Call &operator=(const Call &);
  Call(Ident p1, ListExp *p2);
  ~Call();
  virtual void accept(Visitor *v);
  virtual Call *clone() const;
  void swap(Call &);
};

class EVar : public Exp
{
public:
  Ident ident_;

  EVar(const EVar &);
  EVar &operator=(const EVar &);
  EVar(Ident p1);
  ~EVar();
  virtual void accept(Visitor *v);
  virtual EVar *clone() const;
  void swap(EVar &);
};

class EStr : public Exp
{
public:
  String string_;

  EStr(const EStr &);
  EStr &operator=(const EStr &);
  EStr(String p1);
  ~EStr();
  virtual void accept(Visitor *v);
  virtual EStr *clone() const;
  void swap(EStr &);
};

class EInt : public Exp
{
public:
  Integer integer_;

  EInt(const EInt &);
  EInt &operator=(const EInt &);
  EInt(Integer p1);
  ~EInt();
  virtual void accept(Visitor *v);
  virtual EInt *clone() const;
  void swap(EInt &);
};

class EFalse : public Exp
{
public:

  EFalse(const EFalse &);
  EFalse &operator=(const EFalse &);
  EFalse();
  ~EFalse();
  virtual void accept(Visitor *v);
  virtual EFalse *clone() const;
  void swap(EFalse &);
};

class ETrue : public Exp
{
public:

  ETrue(const ETrue &);
  ETrue &operator=(const ETrue &);
  ETrue();
  ~ETrue();
  virtual void accept(Visitor *v);
  virtual ETrue *clone() const;
  void swap(ETrue &);
};

class EDouble : public Exp
{
public:
  Double double_;

  EDouble(const EDouble &);
  EDouble &operator=(const EDouble &);
  EDouble(Double p1);
  ~EDouble();
  virtual void accept(Visitor *v);
  virtual EDouble *clone() const;
  void swap(EDouble &);
};

class SCall : public Stmt
{
public:
  Ident ident_;
  ListExp *listexp_;

  SCall(const SCall &);
  SCall &operator=(const SCall &);
  SCall(Ident p1, ListExp *p2);
  ~SCall();
  virtual void accept(Visitor *v);
  virtual SCall *clone() const;
  void swap(SCall &);
};

class SAssignment : public Stmt
{
public:
  Ident ident_;
  Exp *exp_;

  SAssignment(const SAssignment &);
  SAssignment &operator=(const SAssignment &);
  SAssignment(Ident p1, Exp *p2);
  ~SAssignment();
  virtual void accept(Visitor *v);
  virtual SAssignment *clone() const;
  void swap(SAssignment &);
};

class SWhile : public Stmt
{
public:
  Exp *exp_;
  Stmt *stmt_;

  SWhile(const SWhile &);
  SWhile &operator=(const SWhile &);
  SWhile(Exp *p1, Stmt *p2);
  ~SWhile();
  virtual void accept(Visitor *v);
  virtual SWhile *clone() const;
  void swap(SWhile &);
};

class SIfThenElse : public Stmt
{
public:
  Exp *exp_;
  Stmt *stmt_1;
  Stmt *stmt_2;

  SIfThenElse(const SIfThenElse &);
  SIfThenElse &operator=(const SIfThenElse &);
  SIfThenElse(Exp *p1, Stmt *p2, Stmt *p3);
  ~SIfThenElse();
  virtual void accept(Visitor *v);
  virtual SIfThenElse *clone() const;
  void swap(SIfThenElse &);
};

class SIfThen : public Stmt
{
public:
  Exp *exp_;
  Stmt *stmt_;

  SIfThen(const SIfThen &);
  SIfThen &operator=(const SIfThen &);
  SIfThen(Exp *p1, Stmt *p2);
  ~SIfThen();
  virtual void accept(Visitor *v);
  virtual SIfThen *clone() const;
  void swap(SIfThen &);
};



class ListExp : public Visitable, public std::vector<Exp*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListExp *clone() const;
};

class ListStmt : public Visitable, public std::vector<Stmt*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListStmt *clone() const;
};

class ListIdent : public Visitable, public std::vector<Ident>
{
public:
  virtual void accept(Visitor *v);
  virtual ListIdent *clone() const;
};

class ListVarDec : public Visitable, public std::vector<VarDec*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListVarDec *clone() const;
};

class ListFPmtDec : public Visitable, public std::vector<FPmtDec*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListFPmtDec *clone() const;
};

class ListProcDec : public Visitable, public std::vector<ProcDec*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListProcDec *clone() const;
};



#endif
